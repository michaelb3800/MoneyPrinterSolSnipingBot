import { EventEmitter } from 'events';
import fetch from 'node-fetch';
import { Settings } from '../config/settingsSchema';
import { Keypair, Connection, Transaction, sendAndConfirmTransaction, PublicKey } from '@solana/web3.js';
import bs58 from 'bs58';

export class Trader extends EventEmitter {
  private settings: Settings;

  constructor(settings: Settings) {
    super();
    this.settings = settings;
  }

  async getSOLPriceUSD(): Promise<number> {
    try {
      const res = await fetch('https://public-api.birdeye.so/public/price?address=So11111111111111111111111111111111111111112');
      const data: any = await res.json();
      return data.data?.value || 0;
    } catch {
      return 0;
    }
  }

  async buildJupiterSwap(mint: string, amount: number) {
    // Jupiter API: https://quote-api.jup.ag/v6/quote
    try {
      const res = await fetch(`https://quote-api.jup.ag/v6/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=${mint}&amount=${amount * 1e9}&slippageBps=${this.settings.Settings.Slippage * 100}`);
      const data: any = await res.json();
      return data;
    } catch {
      return null;
    }
  }

  async signAndSendJitoBundle(tx: Transaction, connection: Connection, priorityFee: number): Promise<string> {
    // TODO: Replace with real Jito bundle submission
    // For now, just send the transaction normally
    const secretKey = bs58.decode(this.settings.Settings.PrivateKey);
    const keypair = Keypair.fromSecretKey(secretKey);
    tx.feePayer = keypair.publicKey;
    tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
    await tx.sign(keypair);
    // Simulate Jito bundle submission with retries
    for (let i = 0; i < 3; i++) {
      try {
        const sig = await sendAndConfirmTransaction(connection, tx, [keypair], { commitment: 'confirmed' });
        return sig;
      } catch (e) {
        // Increase priority fee and retry
        // (In real Jito, set priority fee in bundle)
      }
    }
    throw new Error('Jito bundle submission failed');
  }

  async buy(pool: any, amount: number) {
    const solPrice = await this.getSOLPriceUSD();
    const spendLamports = Math.floor(amount * 1e9);
    const mint = pool.mint;
    const swapRoute = await this.buildJupiterSwap(mint, amount);
    if (!swapRoute) {
      this.emit('trade', { type: 'buy-failed', reason: 'No Jupiter route', pool });
      return;
    }
    if (this.settings.Settings.SimulatedTransaction) {
      // Simulate trade
      const position = {
        pool,
        amount,
        entryPrice: solPrice,
        timestamp: Date.now(),
        route: swapRoute,
        simulated: true,
      };
      this.emit('trade', { type: 'buy', position });
      return;
    }
    // Real trade: build, sign, and send transaction
    const connection = new Connection(this.settings.Settings['RPC-Mainnet']);
    // TODO: Build real transaction from Jupiter route
    const tx = new Transaction(); // Placeholder
    try {
      const sig = await this.signAndSendJitoBundle(tx, connection, 0);
      const position = {
        pool,
        amount,
        entryPrice: solPrice,
        timestamp: Date.now(),
        route: swapRoute,
        txSig: sig,
      };
      this.emit('trade', { type: 'buy', position });
    } catch (e) {
      this.emit('trade', { type: 'buy-failed', reason: (e as Error).message, pool });
    }
  }

  async sell(position: any) {
    // TODO: Build and submit sell transaction (Jupiter or fallback)
    if (this.settings.Settings.SimulatedTransaction) {
      this.emit('trade', { type: 'sell', position });
      return;
    }
    // Real trade: build, sign, and send transaction
    // ...
    this.emit('trade', { type: 'sell', position });
  }
} 
